[["emner-fra-eksperimental-design.html", "Kapitel 11 Emner fra eksperimental design 11.1 Inledning og læringsmålene 11.2 Grundlæggende principper i eksperimentelt design 11.3 Case studies: Simpsons paradoks 11.4 Case studies: Anscombes kvartet 11.5 Undersøgelse af “batch-effekter” 11.6 Problemstillinger 11.7 Yderligere læsning", " Kapitel 11 Emner fra eksperimental design “Amatører sidder og venter på inspiration, resten af os står bare op og går på arbejde.” - Stephen King 11.1 Inledning og læringsmålene Formålet med dette kapitel er at spørge: Hvordan kan vi anvende de værktøjer, vi har lært i kurset, til at undersøge forskellige emner inden for eksperimentelt design? Dette er ikke en grundig introduktion til eksperimentelt design, men snarere en præsentation af nogle nyttige og interessante emner, der effektivt illustrerer, hvorfor det er vigtigt at lave passende visualiseringer af dine data. Forståelsen af, hvordan batch-effekter påvirker en analyse, er særlig vigtig inden for biologifaget, hvor mange store sekventeringsprojekter involverer data indsamlet eller sekventeret over forskellige batches, sekventeringsmaskiner eller forskellige forberedelsesmetoder. I skal være i stand til at Beskrive randomisering, replikation og blokering Beskrive Simpsons paradoks Beskrive Anscombes kvartet Undersøge for batch-effekter med PCA 11.1.1 Video ressourcer Part 1: randomisation, replikation, blocking + confounding Ingen video: læs gerne notaterne nedenfor Part 2: Simpson’s paradox Part 3: Anscombe’s quartet Part 4: Batch effects and principal component analysis. 11.2 Grundlæggende principper i eksperimentelt design 11.2.1 Randomisering og replikation Man laver et eksperiment for at få svar på et bestemt spørgsmål eller en hypotese. Eksperimentet designes ud fra principper, der gør det muligt at fortolke resultaterne fra analysen af datasættet efterfølgende. For at et eksperiment skal være gyldigt, skal det kunne demonstrere hensigtsmæssig replikation og randomisering. Randomisering Målet er at udelukke, at konklusionerne simpelthen kan skyldes varians som følge af en faktor, der ikke direkte er interessant i eksperimentet. Derfor bruger man randomisering til at fordele disse faktorer over de forskellige behandlingsgrupper. Et eksempel kan være ‘double-blinding’ i kliniske eksperimenter - både lægen og patienten har ikke kendskab til, hvem der hører til de forskellige grupper, således at forskelsbehandling indenfor grupperne, som kan påvirke de endelige resultater, undgås. Replikation Dette sker, når man gentager et eksperiment flere gange - for eksempel ved at have flere patienter i hver behandlingsgruppe. Dette tillader os at beregne variabiliteten i data, som er nødvendig for at kunne konkludere om, der er en forskel mellem grupperne. Man kan altså ikke generalisere resultater, som kun er målt på én person. Figure 11.1: randomisation og replikation I ovenstående figur er der 6 replikationer i hver gruppe, der enten er “behandling” eller “kontrol”. I tilfældet “God randomisering” er objekter, som er taget tilfældigt fra populationen, godt matchet mellem de to grupper. I det andet tilfælde, “Dårlig randomisering”, kan man se, at objekternes farver er godt matchet inden for de samme grupper. Dette gør det derfor umuligt at afgøre, om en eventuel forskel mellem “behandling” og “kontrol” i virkeligheden er resultatet af farven frem for de målinger, man gerne vil sammenligne. Forvekslingsvariabler Figuren nedenfor illustrerer alder som en forvekslingsvariabel i et eksperiment, hvor man prøver at forstå sammenhængen mellem aktivitetsniveau og vægtøgning. Det kan se ud som om, at et lavt aktivitetsniveau (afhængig variabel) forklarer vægtøgning (uafhængig variabel), men man er nødt til at tage andre variable i betragtning for at sikre, at sammenhængen ikke skyldes noget andet. For eksempel kunne gruppen med det høje aktivitetsniveau bestå af personer, der er yngre end personerne i gruppen med det lave aktivitetsniveau, og deres alder kan påvirke deres vægtøgning (måske på grund af forskelle i stressniveauer, kost osv.). Blokering Man kan forsøge at kontrollere for ekstra variable, som vi ikke er interesseret i, gennem “blokering”. Blokering udføres ved først at identificere grupper af individer, der ligner hinanden så meget som muligt. Det kan for eksempel være, at tre forskellige forskere har medvirket til at udføre et stort eksperiment med mange patienter og forskellige behandlingsgrupper. Vi er interesseret i, om der er forskelle mellem behandlingsgrupperne, men ikke i, om der er en forskel i forskernes behandling af patienterne. Derfor vil vi gerne ‘blokere’ efter forsker - altså kontrollere for dem som en “batch” effekt. Man kan også blokere efter fx køn, for at sikre at forskellene i behandlingsgrupperne ikke skyldes forskelle mellem mænd og kvinder. Blokering udføres som en del af en lineær model, efter data er indsamlet, men det er nyttigt at tænke over det fra starten. 11.2.2 Eksempel med datasættet ToothGrowth Et godt eksempel på et veludført eksperimentelt design er datasættet ToothGrowth, som er baseret på marsvin - de fik forskellige kosttilskud og doser, og derefter blev længden af deres tænder målt. data(ToothGrowth) ToothGrowth &lt;- ToothGrowth %&gt;% tibble() %&gt;% mutate(dose = as.factor(dose)) summary(ToothGrowth) #&gt; len supp dose #&gt; Min. : 4.20 OJ:30 0.5:20 #&gt; 1st Qu.:13.07 VC:30 1 :20 #&gt; Median :19.25 2 :20 #&gt; Mean :18.81 #&gt; 3rd Qu.:25.27 #&gt; Max. :33.90 Her kan man se, at for hver gruppe (efter supp og dose) er der 10 marsvin - vi har således replikationer over grupperne, og hver supp (supplement) har hver af de tre mulige værdier for “dose”. Hvis vi for eksempel ikke var interesseret i supp men kun i dosis, kunne vi ‘blokere’ efter supp for at afbøde forskelle i effekten af de to supplementer i supp. ToothGrowth %&gt;% dplyr::count(supp,dose) %&gt;% ggplot(aes(x=factor(dose),y=n,fill=factor(dose))) + geom_bar(stat=&quot;identity&quot;) + ylab(&quot;Antal marsvin&quot;) + xlab(&quot;Dosering&quot;) + facet_grid(~supp) + theme_bw() Man skal dog være opmærksom, fordi vi ved ikke, hvordan marsvinene blev tildelt til de forskellige grupper. For eksempel, hvis hanner og hunner ikke er tildelt tilfældigt, kan det forekomme, at supp “OJ” og dosis “0.5” kun har hanmarsvin, og supp “OJ” med dosis “1.0” kun har hunmarsvin. I sådanne tilfælde kunne vi ikke afgøre, om forskellen i dosis “0.5” versus “1.0” er resultatet af dosis eller køn. 11.3 Case studies: Simpsons paradoks (Se også videoressourcer Del 2). Simpsons paradoks er et fascinerende statistisk fænomen, der er en vigtig påmindelse om, at korrelation ikke nødvendigvis indebærer kausalitet, og at det er afgørende at forstå de underliggende data og ikke kun de aggregerede statistikker. Simpsons paradoks opstår, når man drager to modsatte konklusioner fra det samme datasæt - på den ene side, når man kigger på dataene samlet, og på den anden side, når man tager visse grupper i betragtning. Vi kan visualisere Simpsons paradoks gennem eksemplet nedenfor - her har vi to variable x og y, som vi kan bruge til at lave et scatterplot, samt nogle forskellige grupper inden for variablen group. #library(datasauRus) simpsons_paradox &lt;- read.table(&quot;https://www.dropbox.com/s/ysh3qpc7qv0ceut/simpsons_paradox_groups.txt?dl=1&quot;,header=T) simpsons_paradox &lt;- simpsons_paradox %&gt;% tibble() simpsons_paradox FALSE # A tibble: 222 × 3 FALSE x y group FALSE &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; FALSE 1 62.2 70.6 D FALSE 2 52.3 14.7 B FALSE 3 56.4 46.4 C FALSE 4 66.8 66.2 D FALSE 5 66.5 89.2 E FALSE 6 62.4 91.5 E FALSE 7 38.9 6.76 A FALSE 8 39.4 63.1 C FALSE 9 60.9 92.6 E FALSE 10 56.6 45.8 C FALSE # ℹ 212 more rows Hvis vi ignorerer group og kigger på dataene samlet, kan vi se, at der er en stærk positiv sammenhæng mellem x og y. Men når vi opdeler efter de forskellige grupper ved at skrive colour = group, opnår vi faktisk en negativ sammenhæng indenfor hver af grupperne. p1 &lt;- simpsons_paradox %&gt;% ggplot(aes(x,y)) + geom_point() + geom_smooth(method=&quot;lm&quot;,se=FALSE) + theme_classic() p2 &lt;- simpsons_paradox %&gt;% ggplot(aes(x,y,colour=group)) + geom_point() + geom_smooth(method=&quot;lm&quot;,aes(group=group),colour=&quot;black&quot;,se=FALSE) + theme_classic() library(gridExtra) grid.arrange(p1,p2,ncol=2) Simpsons paradoks forekommer oftere end man skulle tro, og derfor er det vigtigt at overveje, hvilke andre variable man også er nødt til at tage i betragtning. 11.3.1 Optagelse på Berkeley Det mest berømte eksempel på Simpsons paradoks drejer sig om optagelsen på Berkeley Universitetet i 1973. Følgende tabel fra Wikipedia (https://en.wikipedia.org/wiki/Simpson%27s_paradox) viser statistikker over antallet af ansøgere samt procentdelen, der blev optaget på universitetet generelt, opdelt efter køn. Figure 11.2: source: wikipedia Hvis vi laver et søjlediagram af tallene, kan man se, at der er en højere procentdel af mænd end kvinder, som blev optaget på universitetet (sagen medførte en retssag mod universitetet). admissions_all &lt;- tibble(&quot;sex&quot;=c(&quot;all&quot;,&quot;men&quot;,&quot;women&quot;),admitted=c(&quot;41&quot;,&quot;44&quot;,&quot;35&quot;)) admissions_all %&gt;% ggplot(aes(x=sex,y=admitted,fill=sex)) + geom_bar(stat=&quot;identity&quot;) + theme_minimal() + ylab(&quot;Procent optaget&quot;) + scale_x_discrete(limits = c(&quot;women&quot;,&quot;men&quot;,&quot;all&quot;)) + coord_flip() Da man dog kiggede lidt nærmere på de samme tal, men opdelte efter de forskellige fakulteter på universitetet, fik man et anderledes billede af situationen. I følgende tabel har vi optagelsestallene for mænd og kvinder på hver af de forskellige fakulteter (A til F). admissions_separate &lt;- tribble( ~department, ~all, ~men, ~women, #------------|-------|-------|--------# &quot;A&quot;, 64, 62, 82, &quot;B&quot;, 63, 63, 68, &quot;C&quot;, 35, 37, 34, &quot;D&quot;, 34, 33, 35, &quot;E&quot;, 25, 28, 24, &quot;F&quot;, 6, 6, 7 ) Man kan se, at for de fleste af fakulteterne er der ikke en markant forskel mellem mænd og kvinder, og i nogle tilfælde havde kvinder faktisk en større sandsynlighed for at blive optaget. admissions_separate %&gt;% pivot_longer(-department,names_to=&quot;sex&quot;,values_to=&quot;admitted&quot;) %&gt;% ggplot(aes(x=department,y=admitted,fill=sex)) + ylab(&quot;Procent optaget&quot;) + geom_bar(stat=&quot;identity&quot;,position = &quot;dodge&quot;,colour=&quot;black&quot;) + theme_minimal() Hvad skyldes denne sammenhæng? Det viste sig, at kvinder havde en tendens til at ansøge indenfor de fakulteter, som var sværest at komme ind på. For eksempel kan man se her, at fakultet E har en relativt lav optagelsesprocent. Det samme fakultet var dog et af dem, hvor betydeligt flere kvinder ansøgte end mænd. applications_E &lt;- tibble(&quot;sex&quot;=c(&quot;all&quot;,&quot;men&quot;,&quot;woman&quot;),applications=c(&quot;584&quot;,&quot;191&quot;,&quot;393&quot;)) applications_E %&gt;% ggplot(aes(x=sex,y=applications,fill=sex)) + geom_bar(stat=&quot;identity&quot;) + theme_minimal() + ylab(&quot;Number of applications to dep. E&quot;) + scale_x_discrete(limits = c(&quot;woman&quot;,&quot;men&quot;,&quot;all&quot;)) + coord_flip() Derfor, selvom kvinder ikke havde en lavere sandsynlighed for at blive optaget end mænd i deres fortrukne fag, var antallet af kvinder, der blev optaget i det hele taget på tværs af alle afdelinger, faktisk lavere end antallet af mænd. 11.4 Case studies: Anscombes kvartet (Se også videoressourcer Del 3). Anscombes kvartet (se også https://en.wikipedia.org/wiki/Anscombe%27s_quartet) er et meget nyttigt og berømt eksempel fra 1973, der fremhæver vigtigheden af at visualisere datasættet. Vi kan hente dataene fra linket nedenfor - der er x-værdier og y-værdier, som kan anvendes til at lave et scatterplot, og der er også set, der refererer til fire forskellige datasæt (derfor ‘kvartet’). anscombe &lt;- read.table(&quot;https://www.dropbox.com/s/mlt7crdik3eih9a/anscombe_long_format.txt?dl=1&quot;,header=T) anscombe &lt;- anscombe %&gt;% tibble() anscombe #&gt; # A tibble: 44 × 3 #&gt; set x y #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 10 8.04 #&gt; 2 1 8 6.95 #&gt; 3 1 13 7.58 #&gt; 4 1 9 8.81 #&gt; 5 1 11 8.33 #&gt; 6 1 14 9.96 #&gt; 7 1 6 7.24 #&gt; 8 1 4 4.26 #&gt; 9 1 12 10.8 #&gt; 10 1 7 4.82 #&gt; # ℹ 34 more rows Formålet med datasættet er, at vi gerne vil fitte en lineær regressionsmodel for at finde den forventede y-værdi afhængig af x (husk lm(y ~ x)). Da vi har fire datasæt, kan vi opdele datasættet efter set og anvende funktionerne nest og map (se Kapitel 7) til at fitte de fire lineære regressionsmodeller. Vi anvender også tidy og glance for at få resuméstatistikker fra de fire modeller: my_func &lt;- ~lm(y ~ x, data = .x) tidy_anscombe_models &lt;- anscombe %&gt;% group_nest(set) %&gt;% mutate(fit = map(data, my_func), tidy = map(fit, tidy), glance = map(fit, glance)) Vi kan anvende unnest på outputtet fra tidy og se på skæringspunktet og hældningen af de fire modeller. Man kan se, at de to parametre er næsten identiske for de fire modeller: tidy_anscombe_models %&gt;% unnest(&quot;tidy&quot;) %&gt;% pivot_wider(id_cols = &quot;set&quot;,names_from = &quot;term&quot;,values_from=&quot;estimate&quot;) #&gt; # A tibble: 4 × 3 #&gt; set `(Intercept)` x #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3.00 0.500 #&gt; 2 2 3.00 0.5 #&gt; 3 3 3.00 0.500 #&gt; 4 4 3.00 0.500 Hvad med de andre parametre fra modellen - lad os eksempelvis kigge på r.squared og p.value fra modellerne, som kan findes i outputtet fra glance. Her kan vi igen se, at de er næsten identiske. tidy_anscombe_models %&gt;% unnest(cols = c(glance)) %&gt;% select(set, r.squared,p.value) #&gt; # A tibble: 4 × 3 #&gt; set r.squared p.value #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.667 0.00217 #&gt; 2 2 0.666 0.00218 #&gt; 3 3 0.666 0.00218 #&gt; 4 4 0.667 0.00216 Hvad med korrelation? Den er også næsten den samme: my_func &lt;- ~cor(.x$x,.x$y) anscombe %&gt;% group_nest(set) %&gt;% mutate(cor = map(data, my_func)) %&gt;% unnest(cor) %&gt;% select(-data) #&gt; # A tibble: 4 × 2 #&gt; set cor #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 0.816 #&gt; 2 2 0.816 #&gt; 3 3 0.816 #&gt; 4 4 0.817 Kan vi så konkludere, at de fire datasæt, som underbygger de forskellige modeller, er identiske? Lad os lave et scatter plot af de fire datasæt (som vi faktisk burde have gjort i starten af vores analyse). anscombe %&gt;% ggplot(aes(x = x, y = y,colour=factor(set))) + geom_point() + facet_wrap(~set) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + theme_minimal() De fire datasæt er meget forskellige. Vi ved, at de alle har samme bedste tilpasning med rette linjer, men de underliggende data er slet ikke de samme. Det første datasæt ser egnet ud til en lineær regressionsanalyse, men vi kan se i datasæt nummer to, at der ikke engang er en lineær sammenhæng. Og de andre to har outlier værdier, hvilket gør, at den bedst tilpassede rette linje ikke passer særlig godt til punkterne. 11.5 Undersøgelse af “batch-effekter” (Se også videoressourcer Part 4). En “batch-effekt” er en systematisk teknisk bias, der opstår, når målinger (f.eks. genekspression) udføres i flere omgange eller “batches”. Dette kan potentielt føre til betydelige forvrængninger og fejlagtige konklusioner i dataanalyse, hvis det ikke tages højde for. Forestil dig, at du udfører et eksperiment, hvor du sammenligner genekspressionen i sundt væv med kræftvæv. Du udfører dine eksperimenter over flere dage, og det viser sig, at alle dine sunde prøver blev behandlet på mandag, og alle dine kræftprøver blev behandlet på tirsdag. Hvis der er en systematisk forskel i, hvordan dine eksperimenter blev udført på de to dage (måske et reagens var lidt anderledes, eller instrumentet blev brugt på en anden måde), vil du se en stor forskel i genekspression mellem dine sunde og kræftprøver. Men denne forskel skyldes faktisk batch-effekten, ikke forskellen mellem sundt og kræftvæv. Man kan også anvende visualiseringer til at undersøge eventuelle batch-effekter eller forvirrende variabler i datasættet. Dette er især vigtigt i store eksperimenter, hvor forskellige prøver eller dele af datasættet bliver indsamlet på forskellige tidspunkter, steder, eller af forskellige personer. Det er ofte tilfældet i sekvenseringsbaserede datasæt, at man ser batch-effekter, og det kan skyldes mange ting, bl.a.: Sekvenseringsdybde Grupper af prøver lavet på forskellige tidspunkter af forskellige individer Sekvenseringsmaskiner - prøver sekvenseret på forskellige maskiner eller ‘lanes’. Lad os tage udgangspunkt i nogle genekspressionssekvenseringsdata fra mus (vi så også dette datasæt, da vi lærte om pivot_longer kombineret med left_join). norm.cts &lt;- read.table(&quot;https://www.dropbox.com/s/3vhwnsnhzsy35nd/bottomly_count_table_normalised.txt?dl=1&quot;) coldata &lt;- read.table(&quot;https://www.dropbox.com/s/el3sm9ncvzbq6xf/bottomly_phenodata.txt?dl=1&quot;) coldata &lt;- coldata %&gt;% tibble() norm.cts &lt;- as_tibble(norm.cts[1:1000,],rownames=&quot;gene&quot;) Jeg begynder med at vælge kun de rækker, der har mindst 50 counts, for at undgå gener med lave ekspressionsniveauer. Det næste jeg gør er at transformere dataene til logaritmisk form (funktion map_if()) for at opnå en bedre fordeling i datasættet. #normalisere og filtrere dataene norm.cts &lt;- norm.cts %&gt;% filter(rowSums(norm.cts %&gt;% select(-gene))&gt;50) %&gt;% map_if(is.numeric,~log(.x+1)) %&gt;% as_tibble() norm.cts #&gt; # A tibble: 10,193 × 22 #&gt; gene SRX033480 SRX033488 SRX033481 SRX033489 SRX033482 SRX033490 SRX033483 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ENSMUS… 6.35 6.32 6.21 6.29 6.31 6.27 6.30 #&gt; 2 ENSMUS… 3.51 3.56 3.57 3.27 2.99 3.61 3.56 #&gt; 3 ENSMUS… 3.19 3.50 3.08 3.21 3.14 3.09 3.22 #&gt; 4 ENSMUS… 6.69 6.48 6.38 6.35 6.39 6.34 6.50 #&gt; 5 ENSMUS… 6.05 6.37 6.17 6.26 6.16 6.06 6.13 #&gt; 6 ENSMUS… 2.89 2.94 3.16 3.21 3.77 3.30 3.11 #&gt; 7 ENSMUS… 3.42 3.12 3.86 4.36 3.77 3.99 4.24 #&gt; 8 ENSMUS… 3.42 2.94 3.52 3.41 3.57 3.60 2.99 #&gt; 9 ENSMUS… 5.02 4.98 4.49 4.27 4.67 4.35 4.81 #&gt; 10 ENSMUS… 5.13 4.88 4.97 4.76 4.82 4.79 4.96 #&gt; # ℹ 10,183 more rows #&gt; # ℹ 14 more variables: SRX033476 &lt;dbl&gt;, SRX033478 &lt;dbl&gt;, SRX033479 &lt;dbl&gt;, #&gt; # SRX033472 &lt;dbl&gt;, SRX033473 &lt;dbl&gt;, SRX033474 &lt;dbl&gt;, SRX033475 &lt;dbl&gt;, #&gt; # SRX033491 &lt;dbl&gt;, SRX033484 &lt;dbl&gt;, SRX033492 &lt;dbl&gt;, SRX033485 &lt;dbl&gt;, #&gt; # SRX033493 &lt;dbl&gt;, SRX033486 &lt;dbl&gt;, SRX033494 &lt;dbl&gt; Så der er omkring 10.000 gener i rækkerne, og der er 21 forskellige prøver, der spreder sig over kolonnerne. Vi har også nogle prøveoplysninger - der er to forskellige stammer af mus og også forskellige batches, som vi gerne vil undersøge nærmere. coldata #&gt; # A tibble: 21 × 5 #&gt; column num.tech.reps strain batch lane.number #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 SRX033480 1 C57BL.6J 6 1 #&gt; 2 SRX033488 1 C57BL.6J 7 1 #&gt; 3 SRX033481 1 C57BL.6J 6 2 #&gt; 4 SRX033489 1 C57BL.6J 7 2 #&gt; 5 SRX033482 1 C57BL.6J 6 3 #&gt; 6 SRX033490 1 C57BL.6J 7 3 #&gt; 7 SRX033483 1 C57BL.6J 6 5 #&gt; 8 SRX033476 1 C57BL.6J 4 6 #&gt; 9 SRX033478 1 C57BL.6J 4 7 #&gt; 10 SRX033479 1 C57BL.6J 4 8 #&gt; # ℹ 11 more rows Vi kan se på, hvor mange prøver vi har for hver kombination af stamme og batch i datasættet: table(coldata$strain, coldata$batch) #&gt; #&gt; 4 6 7 #&gt; C57BL.6J 3 4 3 #&gt; DBA.2J 4 3 4 Så man kan se, at både stammen er repræsenteret med tre eller fire prøver i hver af de tre batches. Der er derfor replikation, og da vi har fået repræsenteret hver kombination af stamme og batch, kan vi eventuelt blokere efter batch for at fjerne dens effekt. Her har vi ikke tid til at se på metoder til at fjerne batch-effekter, men det er vigtigt, at vi er i stand til at opdage dem. 11.5.1 Principal component analyse Man kan undersøge mulige batch-effekter via principal component analyse. Først skal vi lave en “transpose” af datasættet således at variablerne (samples) bliver i rækkerne og observationerne (genes) er som kolonnerne. Det er ikke helt ligetil i tidyverse, men her er en måde at gøre det på: norm.cts.transpose &lt;- as_tibble(t(norm.cts[,-1])) colnames(norm.cts.transpose) &lt;- norm.cts %&gt;% pull(gene) norm.cts.transpose %&gt;% mutate(sample = colnames(norm.cts)[-1],.before=1) #&gt; # A tibble: 21 × 10,194 #&gt; sample ENSMUSG00000000001 ENSMUSG00000000056 ENSMUSG00000000058 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 SRX033480 6.35 3.51 3.19 #&gt; 2 SRX033488 6.32 3.56 3.50 #&gt; 3 SRX033481 6.21 3.57 3.08 #&gt; 4 SRX033489 6.29 3.27 3.21 #&gt; 5 SRX033482 6.31 2.99 3.14 #&gt; 6 SRX033490 6.27 3.61 3.09 #&gt; 7 SRX033483 6.30 3.56 3.22 #&gt; 8 SRX033476 6.03 3.69 2.83 #&gt; 9 SRX033478 6.30 3.42 3.73 #&gt; 10 SRX033479 5.88 3.98 3.24 #&gt; # ℹ 11 more rows #&gt; # ℹ 10,190 more variables: ENSMUSG00000000078 &lt;dbl&gt;, ENSMUSG00000000088 &lt;dbl&gt;, #&gt; # ENSMUSG00000000093 &lt;dbl&gt;, ENSMUSG00000000120 &lt;dbl&gt;, #&gt; # ENSMUSG00000000125 &lt;dbl&gt;, ENSMUSG00000000126 &lt;dbl&gt;, #&gt; # ENSMUSG00000000127 &lt;dbl&gt;, ENSMUSG00000000131 &lt;dbl&gt;, #&gt; # ENSMUSG00000000149 &lt;dbl&gt;, ENSMUSG00000000167 &lt;dbl&gt;, #&gt; # ENSMUSG00000000168 &lt;dbl&gt;, ENSMUSG00000000171 &lt;dbl&gt;, … Heldigvis er der en pakke, som kan gøre processen meget hurtigere: library(sjmisc) norm.cts.transpose &lt;- norm.cts %&gt;% rotate_df(cn=TRUE,rn=&quot;sample&quot;) norm.cts.transpose[1:6,1:5] #&gt; sample ENSMUSG00000000001 ENSMUSG00000000056 ENSMUSG00000000058 #&gt; 1 SRX033480 6.352707 3.514892 3.190250 #&gt; 2 SRX033488 6.317191 3.560812 3.495351 #&gt; 3 SRX033481 6.208840 3.571591 3.079332 #&gt; 4 SRX033489 6.289602 3.265114 3.210200 #&gt; 5 SRX033482 6.307351 2.989835 3.136775 #&gt; 6 SRX033490 6.268945 3.613359 3.090954 #&gt; ENSMUSG00000000078 #&gt; 1 6.689454 #&gt; 2 6.477961 #&gt; 3 6.377990 #&gt; 4 6.345142 #&gt; 5 6.389898 #&gt; 6 6.337397 Nu kan vi udføre en principal component analyse: pca_fit &lt;- norm.cts.transpose %&gt;% select(where(is.numeric)) %&gt;% # behold kun numeriske kolonner prcomp(scale = TRUE) # udfør PCA på skalerede data Så kan vi bruge vores standarde måde at visualisere principal components på: library(ggrepel) pca_fit_augment &lt;- pca_fit %&gt;% augment(norm.cts.transpose) pca_fit_augment %&gt;% ggplot(aes(x=.fittedPC1,y=.fittedPC2)) + geom_point() + geom_text_repel(aes(label=sample)) + theme_bw() Anvend left_join til at få oplysningen med: pca_fit_augment &lt;- pca_fit_augment %&gt;% left_join(coldata %&gt;% rename(sample = column),by=&quot;sample&quot;) tail(colnames(pca_fit_augment)) #&gt; [1] &quot;.fittedPC20&quot; &quot;.fittedPC21&quot; &quot;num.tech.reps&quot; &quot;strain&quot; #&gt; [5] &quot;batch&quot; &quot;lane.number&quot; pca_fit_augment %&gt;% ggplot(aes(x=.fittedPC1,y=.fittedPC2,colour=as.factor(batch),shape=strain)) + geom_point(size=3) + geom_text_repel(aes(label=sample)) + theme_bw() p1 &lt;- pca_fit_augment %&gt;% ggplot(aes(x=factor(batch),y=.fittedPC1,fill=factor(batch))) + geom_boxplot(show.legend = F) + geom_jitter(show.legend = F) + theme_minimal() + ggtitle(&quot;Batches PC1&quot;) p2 &lt;- pca_fit_augment %&gt;% ggplot(aes(x=factor(batch),y=.fittedPC2,fill=factor(batch))) + geom_boxplot(show.legend = F) + geom_jitter(show.legend = F) + theme_minimal() + ggtitle(&quot;Batch PC2&quot;) library(gridExtra) grid.arrange(p1,p2,ncol=2) Man kan også lav en heatmap: cor_mat &lt;- cor(norm.cts[,-1]) row.names(cor_mat) &lt;- coldata$batch colnames(cor_mat) &lt;- coldata$strain heatmap(cor_mat) 11.5.2 EKSTRA: Batch effect correction med ComBat()-funktionen ComBat-pakken i R hjælper med at korrigere for batch-effekter, så forskelle mellem prøver skyldes biologisk variation og ikke tekniske forskelle. #if (!require(&quot;BiocManager&quot;, quietly = TRUE)) # install.packages(&quot;BiocManager&quot;) #BiocManager::install(&quot;sva&quot;) library(sva) corrected &lt;- sva::ComBat(dat=norm.cts[1:100,] %&gt;% select(-gene),batch=coldata %&gt;% pull(batch)) corrected &lt;- as_tibble(corrected) %&gt;% mutate(gene = norm.cts[1:100,] %&gt;% pull(gene),.before=1) Så kan man lave præcis samme procedure som i ovenstående på den korrigede dataframe: corrected.transpose &lt;- corrected %&gt;% rotate_df(cn=TRUE,rn=&quot;sample&quot;) pca_fit &lt;- corrected.transpose %&gt;% select(where(is.numeric)) %&gt;% # behold kun numeriske kolonner prcomp(scale = TRUE) # udfør PCA på skalerede data pca_fit_augment &lt;- pca_fit %&gt;% augment(corrected.transpose) pca_fit_augment &lt;- pca_fit_augment %&gt;% left_join(coldata %&gt;% rename(sample = column),by=&quot;sample&quot;) pca_fit_augment &lt;- pca_fit_augment %&gt;% mutate(batch=as.factor(batch)) Og så lav en plot: PCA1 &lt;- pca_fit_augment %&gt;% ggplot(aes(x=.fittedPC1,y=.fittedPC2,colour=batch,shape=strain)) + geom_point(size=3) + geom_text_repel(aes(label=sample)) + theme_bw() PCA2 &lt;- pca_fit_augment %&gt;% ggplot(aes(x=.fittedPC1,y=.fittedPC2,shape=batch,colour=strain)) + geom_point(size=3) + geom_text_repel(aes(label=sample)) + theme_bw() grid.arrange(PCA1,PCA2,ncol=2) –&gt; 11.6 Problemstillinger Problem 1) Quiz på Absalon - experimental Problem 2) Eksperimentelt design Jeg udfører et eksperiment, hvor patienter modtager et af tre forskellige kosttilskud (Gruppe 1, 2 og 3). Der er 5 patienter i hver gruppe, og jeg ønsker at undersøge, om patienternes energiniveau i gennemsnit varierer mellem de tre grupper. Alderen på patienterne i hver af de tre grupper er: Gruppe 1: 18, 23, 31, 25, 19 Gruppe 2: 24, 29, 35, 21, 30 Gruppe 3: 43, 52, 33, 39, 40 Hvad er problemet med det eksperimentelle design her? Lav boxplots for at illustrere fordelingen af alderne for hver af de tre grupper (du skal starte med at lave en tibble, der indeholder dataene). Hvis man finder en signifikant forskel mellem de tre kosttilskud, kan man så stole på resultaterne? Hvilke andre variabler end alder kunne være årsag til en eventuel forskel mellem de tre kosttilskud, og som muligvis skulle tages i betragtning? Hvad kan man gøre for at løse problemet med det ovenstående eksperimentelle design? Problem 3) Simpsons paradoks Genbesøg af Lung Cap-data Indlæs LungCapData og tilføj den kategoriske variabel Age.Group: LungCapData &lt;- read.csv(&quot;https://www.dropbox.com/s/ke27fs5d37ks1hm/LungCapData.csv?dl=1&quot;) LungCapData$Age.Group &lt;- cut(LungCapData$Age,breaks=c(1,13,15,17,19),right=FALSE,include.lowest = TRUE) levels(LungCapData$Age.Group) &lt;- c(&quot;&lt;13&quot;,&quot;13-14&quot;,&quot;15-16&quot;,&quot;17+&quot;) a) Lav boxplots med smoke på x-aksen og LungCap på y-aksen. + Bemærk hvilken gruppe der har den højeste lungekapacitet. b) Lav samme plot, men adskilt efter Age.Group, og beskriv, hvordan det er et eksempel på Simpsons paradoks. c) Lav et boxplot med Age på y-aksen og Smoke på x-aksen for at understøtte forklaringen på, hvorfor man ser Simpsons paradoks i dette datasæt. Problem 4) Anscombes analyse Gentag Anscombes analyse med dinosaurdatasættet: library(datasauRus) #installer denne pakke data_dozen &lt;- datasauRus::datasaurus_dozen data_dozen FALSE # A tibble: 1,846 × 3 FALSE dataset x y FALSE &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; FALSE 1 dino 55.4 97.2 FALSE 2 dino 51.5 96.0 FALSE 3 dino 46.2 94.5 FALSE 4 dino 42.8 91.4 FALSE 5 dino 40.8 88.3 FALSE 6 dino 38.7 84.9 FALSE 7 dino 35.6 79.9 FALSE 8 dino 33.1 77.6 FALSE 9 dino 29.0 74.5 FALSE 10 dino 26.2 71.4 FALSE # ℹ 1,836 more rows a) Fit en lineær regressionsmodel for hvert af datasættene (brug group_by, nest og map i kombination med en custom funktion), hvor y er den afhængige variabel og x er den uafhængige variabel. Anvend også tidy og glance på alle modellerne. b) Brug resultaterne fra tidy til at undersøge hældning og skæring med y-aksen for de forskellige modeller - ligner de hinanden? c) Brug også resultaterne fra glance til at undersøge r.squared og p.value. d) Er de alle det samme datasæt? Lav et scatter plot opdelt efter de forskellige datasæt. Hvordan ser de bedste rette linjer ud på plottene? Problem 5) Vi vil gerne undersøge eventuelle batcheffekter i det følgende datasæt. Det er simulerede “single cell”-sekvenserings count data (dataframen cse50) samt dataframen batches, som angiver hvilken batch hver af de 500 celler tilhører. cse50 &lt;- read.table(&quot;https://www.dropbox.com/s/o0wzojpcsekeg6z/cell_mix_50_counts.txt?dl=1&quot;) batches &lt;- read.table(&quot;https://www.dropbox.com/s/4t382bfgro46ka5/cell_mix_50_batches.txt?dl=1&quot;) batches &lt;- tibble(&quot;batch&quot;=batches %&gt;% pull(batch)) cse50 &lt;- tibble(cse50) a) Anvend map_df til at transformere disse data til log-skala (tilføj 1 først og tag logaritmen bagefter). b) Udfør PCA på det transformeret datasæt. c) Brug dine PCA-resultater til at få den rotation matrix d) Tilføj oplysningerne fra dataframen batches til din rotation matrix (tilføj først en ny kolonne “column” til batches, der er lig med names(cse50)). e) Brug pivot_wider og lav et plot af de første to principal komponenter, hvor du angiver farve efter batch. f) Lav også boxplots for de første to prinpical components fordelt efter batch og kommenter kort på eventuelle batch effekts i datasættet. Problem 6 Yderligere Simpson’s paradoks Kør følgende kode for at indlæse og bearbejde det følgende datasæt airlines. airlines &lt;- read.table(&quot;http://www.utsc.utoronto.ca/~butler/d29/airlines.txt&quot;,header=T) airlines &lt;- airlines %&gt;% pivot_longer(-airport) %&gt;% separate(name,sep=&quot;_&quot;,into = c(&quot;airline&quot;,&quot;status&quot;)) %&gt;% mutate(airline = recode(airline, aa = &quot;Alaska&quot;, aw = &quot;American&quot;)) %&gt;% pivot_wider(names_from=status,values_from=value) %&gt;% mutate(&quot;ontime&quot; = ontime + delayed) %&gt;% rename(flights = ontime) a) Opsummer antallet af flights og antallet af delayed over de forskellige lufthavne for at få et samlet tal for hver flyselskab. b) Beregn også andelen af flyvninger, der er forsinkede, i hvert flyselskab (igen samlet over alle lufthavne). Lav et søjlediagram for at vise proportionerne. c) Denne gang, opsummer over de to flyselskaber for at få et samlet tal for hver lufthavn. Beregn også andelen af flyvninger, der er forsinkede, og lav et plot. d) Denne gang, beregn andelen af flyvninger, der er forsinkede, for hver kombination af både lufthavn og flyselskab. Omsæt igen dette til et plot. e) Kan du forklare dette? Hint: kig eksempelvis på rådataene og især lufthavnen “Phoenix”. 11.7 Yderligere læsning Simpson’s paradox og airlines: http://ritsokiguess.site/docs/2018/04/07/simpson-s-paradox-log-linear-modelling-and-the-tidyverse/ Batch effekt correction: https://en.wikipedia.org/wiki/Batch_effect#Correction "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
